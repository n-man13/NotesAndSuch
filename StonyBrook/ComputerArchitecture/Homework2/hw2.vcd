$date
	Tue Oct 21 11:07:09 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module processor_tb $end
$var wire 1 ! clk $end
$scope module myClock $end
$var reg 1 ! clk $end
$upscope $end
$scope module myProcessor $end
$var wire 32 " ADDI_in_wire [31:0] $end
$var wire 32 # ADDI_out_wire [31:0] $end
$var wire 32 $ ALU_out_wire [31:0] $end
$var wire 32 % ANDI_in_wire [31:0] $end
$var wire 32 & ANDI_out_wire [31:0] $end
$var wire 32 ' ORI_in_wire [31:0] $end
$var wire 32 ( ORI_out_wire [31:0] $end
$var wire 32 ) initial_pc [31:0] $end
$var wire 32 * instruction_wire [31:0] $end
$var wire 32 + read_data_wire [31:0] $end
$var wire 32 , reg_data1_wire [31:0] $end
$var wire 32 - reg_data2_wire [31:0] $end
$var wire 16 . immediate_wire [15:0] $end
$var wire 1 / clk $end
$var reg 32 0 ADDI_in [31:0] $end
$var reg 32 1 ADDI_out [31:0] $end
$var reg 3 2 ALU_Sel [2:0] $end
$var reg 32 3 ALU_out [31:0] $end
$var reg 32 4 ANDI_in [31:0] $end
$var reg 32 5 ANDI_out [31:0] $end
$var reg 32 6 ORI_in [31:0] $end
$var reg 32 7 ORI_out [31:0] $end
$var reg 32 8 a [31:0] $end
$var reg 32 9 b [31:0] $end
$var reg 5 : base [4:0] $end
$var reg 6 ; funct [5:0] $end
$var reg 32 < instruction [31:0] $end
$var reg 32 = mem_address [31:0] $end
$var reg 32 > mem_data [31:0] $end
$var reg 6 ? opcode [5:0] $end
$var reg 32 @ pc [31:0] $end
$var reg 5 A rd [4:0] $end
$var reg 32 B read_data [31:0] $end
$var reg 5 C read_reg1 [4:0] $end
$var reg 5 D read_reg2 [4:0] $end
$var reg 32 E reg_data1 [31:0] $end
$var reg 32 F reg_data2 [31:0] $end
$var reg 5 G rs [4:0] $end
$var reg 5 H rt [4:0] $end
$var reg 32 I write_data [31:0] $end
$var reg 1 J write_enable_mem $end
$var reg 1 K write_enable_reg $end
$var reg 5 L write_reg [4:0] $end
$scope module mem $end
$var wire 32 M address [31:0] $end
$var wire 32 N write_data [31:0] $end
$var wire 1 J write_enable $end
$var reg 32 O read_data [31:0] $end
$var integer 32 P i [31:0] $end
$upscope $end
$scope module myADDI $end
$var wire 16 Q immediate [15:0] $end
$var wire 32 R reg_in [31:0] $end
$var wire 32 S reg_out [31:0] $end
$var wire 32 T sign_extended_value [31:0] $end
$scope module myALU $end
$var wire 32 U A [31:0] $end
$var wire 3 V ALU_Sel [2:0] $end
$var wire 32 W B [31:0] $end
$var reg 32 X ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myALU $end
$var wire 32 Y A [31:0] $end
$var wire 3 Z ALU_Sel [2:0] $end
$var wire 32 [ B [31:0] $end
$var reg 32 \ ALU_Out [31:0] $end
$upscope $end
$scope module myANDI $end
$var wire 16 ] immediate [15:0] $end
$var wire 32 ^ reg_in [31:0] $end
$var wire 32 _ reg_out [31:0] $end
$var wire 32 ` sign_extended_value [31:0] $end
$scope module myALU $end
$var wire 32 a A [31:0] $end
$var wire 3 b ALU_Sel [2:0] $end
$var wire 32 c B [31:0] $end
$var reg 32 d ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myClock $end
$var reg 1 / clk $end
$upscope $end
$scope module myORI $end
$var wire 16 e immediate [15:0] $end
$var wire 32 f reg_in [31:0] $end
$var wire 32 g reg_out [31:0] $end
$var wire 32 h sign_extended_immediate [31:0] $end
$scope module myALU $end
$var wire 32 i A [31:0] $end
$var wire 3 j ALU_Sel [2:0] $end
$var wire 32 k B [31:0] $end
$var reg 32 l ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module prog_mem $end
$var wire 32 m pc [31:0] $end
$var reg 32 n instruction [31:0] $end
$upscope $end
$scope module regFile $end
$var wire 5 o readReg1 [4:0] $end
$var wire 5 p readReg2 [4:0] $end
$var wire 32 q writeData [31:0] $end
$var wire 1 K writeEnable $end
$var wire 5 r writeReg [4:0] $end
$var reg 32 s readData1 [31:0] $end
$var reg 32 t readData2 [31:0] $end
$var integer 32 u i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 u
bx t
bx s
bx r
bx q
bx p
bx o
b100000000010000000000000000100 n
b0 m
bx l
bx k
b11 j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
b10 b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
b0 V
bx U
bx T
bx S
bx R
bx Q
b100000000 P
bx O
bx N
bx M
bx L
xK
xJ
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
b0 @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
0/
bx .
bx -
bx ,
bx +
bx *
b0 )
bx (
bx '
bx &
bx %
bx $
bx #
bx "
0!
$end
#5000
b100000000010010000000000001111 n
b1 @
b1 m
1/
1!
