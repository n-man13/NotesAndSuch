$date
	Tue Oct 21 23:33:56 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module processor_tb $end
$scope module myProcessor $end
$var wire 32 ! ADDI_in_wire [31:0] $end
$var wire 32 " ANDI_in_wire [31:0] $end
$var wire 32 # ORI_in_wire [31:0] $end
$var wire 32 $ initial_pc [31:0] $end
$var wire 1 % write_enable $end
$var wire 32 & reg_data2 [31:0] $end
$var wire 32 ' reg_data1 [31:0] $end
$var wire 32 ( read_data_wire [31:0] $end
$var wire 32 ) instruction [31:0] $end
$var wire 16 * immediate_wire [15:0] $end
$var wire 1 + clk $end
$var wire 32 , ORI_out_wire [31:0] $end
$var wire 32 - ANDI_out_wire [31:0] $end
$var wire 32 . ALU_out_wire [31:0] $end
$var wire 32 / ADDI_out_wire [31:0] $end
$var reg 32 0 ADDI_in [31:0] $end
$var reg 3 1 ALU_Sel [2:0] $end
$var reg 32 2 ANDI_in [31:0] $end
$var reg 32 3 ORI_in [31:0] $end
$var reg 32 4 a [31:0] $end
$var reg 32 5 b [31:0] $end
$var reg 5 6 base [4:0] $end
$var reg 6 7 funct [5:0] $end
$var reg 32 8 mem_address [31:0] $end
$var reg 32 9 mem_data [31:0] $end
$var reg 6 : opcode [5:0] $end
$var reg 32 ; pc [31:0] $end
$var reg 5 < rd [4:0] $end
$var reg 5 = read_reg1 [4:0] $end
$var reg 5 > read_reg2 [4:0] $end
$var reg 5 ? rs [4:0] $end
$var reg 5 @ rt [4:0] $end
$var reg 32 A write_data [31:0] $end
$var reg 1 B write_enable_mem $end
$var reg 1 C write_enable_reg $end
$var reg 5 D write_reg [4:0] $end
$scope module mem $end
$var wire 32 E addr [31:0] $end
$var wire 32 F readData [31:0] $end
$var wire 32 G writeData [31:0] $end
$var wire 1 B writeEnable $end
$var wire 1 + clk $end
$var integer 32 H i [31:0] $end
$upscope $end
$scope module myADDI $end
$var wire 16 I immediate [15:0] $end
$var wire 32 J reg_in [31:0] $end
$var wire 32 K sign_extended_value [31:0] $end
$var wire 32 L reg_out [31:0] $end
$scope module myADDI_ALU $end
$var wire 32 M A [31:0] $end
$var wire 3 N ALU_Sel [2:0] $end
$var wire 32 O B [31:0] $end
$var reg 32 P ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myALU $end
$var wire 32 Q A [31:0] $end
$var wire 3 R ALU_Sel [2:0] $end
$var wire 32 S B [31:0] $end
$var reg 32 T ALU_Out [31:0] $end
$upscope $end
$scope module myANDI $end
$var wire 16 U immediate [15:0] $end
$var wire 32 V reg_in [31:0] $end
$var wire 32 W zero_extended_value [31:0] $end
$var wire 32 X reg_out [31:0] $end
$scope module myALU $end
$var wire 32 Y A [31:0] $end
$var wire 3 Z ALU_Sel [2:0] $end
$var wire 32 [ B [31:0] $end
$var reg 32 \ ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myClock $end
$var reg 1 + clk $end
$upscope $end
$scope module myORI $end
$var wire 16 ] immediate [15:0] $end
$var wire 32 ^ reg_in [31:0] $end
$var wire 32 _ zero_extended_immediate [31:0] $end
$var wire 32 ` reg_out [31:0] $end
$scope module myALU $end
$var wire 32 a A [31:0] $end
$var wire 3 b ALU_Sel [2:0] $end
$var wire 32 c B [31:0] $end
$var reg 32 d ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module prog_mem $end
$var wire 32 e pc [31:0] $end
$var wire 32 f instruction [31:0] $end
$var reg 32 g instruction_reg [31:0] $end
$upscope $end
$scope module regFile $end
$var wire 1 + clk $end
$var wire 32 h readData1 [31:0] $end
$var wire 32 i readData2 [31:0] $end
$var wire 5 j readReg1 [4:0] $end
$var wire 5 k readReg2 [4:0] $end
$var wire 32 l writeData [31:0] $end
$var wire 1 C writeEnable $end
$var wire 5 m writeReg [4:0] $end
$var integer 32 n i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 n
b1000 m
b100 l
b0 k
b0 j
b0 i
b0 h
b100000000010000000000000000100 g
b100000000010000000000000000100 f
b0 e
bx1xx d
b100 c
b11 b
bx a
bx1xx `
b100 _
bx ^
b100 ]
b0x00 \
b100 [
b10 Z
bx Y
b0x00 X
b100 W
bx V
b100 U
b0 T
b0 S
b110 R
b0 Q
b100 P
b100 O
b0 N
b0 M
b100 L
b100 K
b0 J
b100 I
b100000000 H
bx G
bx F
bx E
b1000 D
1C
0B
b100 A
b1000 @
b0 ?
b0 >
b0 =
b0 <
b0 ;
b1000 :
bx 9
bx 8
b0 7
bx 6
b0 5
b0 4
bx 3
bx 2
b110 1
b0 0
b100 /
b0 .
b0x00 -
bx1xx ,
1+
b100 *
b100000000010000000000000000100 )
bx (
b0 '
b0 &
1%
b0 $
bx #
bx "
b0 !
$end
#5000
0+
#10000
b1111 A
b1111 l
b1111 /
b1111 L
b1111 P
b0xxxx -
b0xxxx X
b0xxxx \
bx1111 ,
bx1111 `
bx1111 d
b1111 K
b1111 O
b1111 W
b1111 [
b1111 _
b1111 c
b1111 *
b1111 I
b1111 U
b1111 ]
b1001 D
b1001 m
b1001 @
b100000000010010000000000001111 )
b100000000010010000000000001111 f
b100000000010010000000000001111 g
1%
1C
b1 ;
b1 e
1+
#15000
0+
#20000
b10100 A
b10100 l
b10100 /
b10100 L
b10100 P
b0x0x00 -
b0x0x00 X
b0x0x00 \
bx1x1xx ,
bx1x1xx `
bx1x1xx d
b10100 K
b10100 O
b10100 W
b10100 [
b10100 _
b10100 c
b10100 *
b10100 I
b10100 U
b10100 ]
b1010 D
b1010 m
b1010 @
b100000000010100000000000010100 )
b100000000010100000000000010100 f
b100000000010100000000000010100 g
1%
1C
b10 ;
b10 e
1+
#25000
0+
#30000
b1000 A
b1000 l
b1000 /
b1000 L
b1000 P
b0x000 -
b0x000 X
b0x000 \
bx1xxx ,
bx1xxx `
bx1xxx d
b1000 K
b1000 O
b1000 W
b1000 [
b1000 _
b1000 c
b1000 *
b1000 I
b1000 U
b1000 ]
b10001 D
b10001 m
b10001 @
b100000000100010000000000001000 )
b100000000100010000000000001000 f
b100000000100010000000000001000 g
1%
1C
b11 ;
b11 e
1+
#35000
0+
#40000
bx (
bx F
b0 -
b0 X
b0 \
bx ,
bx `
bx d
bx /
bx L
bx P
b0 K
b0 O
b0 W
b0 [
b0 _
b0 c
b0 *
b0 I
b0 U
b0 ]
b100 9
b100 G
1B
bx 8
bx E
bx !
bx J
bx M
bx 0
b100 &
b100 i
b1000 >
b1000 k
bx '
bx h
bx =
bx j
b1000 @
b10001 ?
b101011 :
b10101110001010000000000000000000 )
b10101110001010000000000000000000 f
b10101110001010000000000000000000 g
0%
0C
b100 ;
b100 e
1+
#45000
0+
#50000
b0x000 -
b0x000 X
b0x000 \
bx1xxx ,
bx1xxx `
bx1xxx d
b1000 K
b1000 O
b1000 W
b1000 [
b1000 _
b1000 c
b1000 *
b1000 I
b1000 U
b1000 ]
b1111 9
b1111 G
b1111 &
b1111 i
b1001 >
b1001 k
b1001 @
b10101110001010010000000000001000 )
b10101110001010010000000000001000 f
b10101110001010010000000000001000 g
1B
b101 ;
b101 e
1+
#55000
0+
#60000
b0xxxxxxxxxxxxxx00 -
b0xxxxxxxxxxxxxx00 X
b0xxxxxxxxxxxxxx00 \
bx11111111111111xx ,
bx11111111111111xx `
bx11111111111111xx d
b11111111111111111111111111111100 K
b11111111111111111111111111111100 O
b1111111111111100 W
b1111111111111100 [
b1111111111111100 _
b1111111111111100 c
b1111111111111100 *
b1111111111111100 I
b1111111111111100 U
b1111111111111100 ]
b10100 9
b10100 G
b10100 &
b10100 i
b1010 >
b1010 k
b1010 @
b10101110001010101111111111111100 )
b10101110001010101111111111111100 f
b10101110001010101111111111111100 g
1B
b110 ;
b110 e
1+
#65000
0+
#70000
b0 -
b0 X
b0 \
bx ,
bx `
bx d
b0 K
b0 O
b0 W
b0 [
b0 _
b0 c
b0 *
b0 I
b0 U
b0 ]
b111111 :
b11111100000000000000000000000000 )
b11111100000000000000000000000000 f
b11111100000000000000000000000000 g
0B
b111 ;
b111 e
1+
