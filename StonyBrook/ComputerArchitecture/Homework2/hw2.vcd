$date
	Mon Oct 20 23:30:39 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module processor_tb $end
$scope module myProcessor $end
$var wire 32 ! ADDI_in_wire [31:0] $end
$var wire 32 " ADDI_out_wire [31:0] $end
$var wire 32 # ALU_out_wire [31:0] $end
$var wire 32 $ ANDI_in_wire [31:0] $end
$var wire 32 % ANDI_out_wire [31:0] $end
$var wire 32 & ORI_in_wire [31:0] $end
$var wire 32 ' ORI_out_wire [31:0] $end
$var wire 32 ( initial_pc [31:0] $end
$var wire 32 ) instruction_wire [31:0] $end
$var wire 32 * read_data_wire [31:0] $end
$var wire 32 + reg_data1_wire [31:0] $end
$var wire 32 , reg_data2_wire [31:0] $end
$var wire 16 - immediate_wire [15:0] $end
$var wire 1 . clk $end
$var reg 32 / ADDI_in [31:0] $end
$var reg 32 0 ADDI_out [31:0] $end
$var reg 3 1 ALU_Sel [2:0] $end
$var reg 32 2 ALU_out [31:0] $end
$var reg 32 3 ANDI_in [31:0] $end
$var reg 32 4 ANDI_out [31:0] $end
$var reg 32 5 ORI_in [31:0] $end
$var reg 32 6 ORI_out [31:0] $end
$var reg 32 7 a [31:0] $end
$var reg 32 8 b [31:0] $end
$var reg 5 9 base [4:0] $end
$var reg 6 : funct [5:0] $end
$var reg 32 ; instruction [31:0] $end
$var reg 32 < mem_address [31:0] $end
$var reg 32 = mem_data [31:0] $end
$var reg 6 > opcode [5:0] $end
$var reg 32 ? pc [31:0] $end
$var reg 5 @ rd [4:0] $end
$var reg 32 A read_data [31:0] $end
$var reg 5 B read_reg1 [4:0] $end
$var reg 5 C read_reg2 [4:0] $end
$var reg 32 D reg_data1 [31:0] $end
$var reg 32 E reg_data2 [31:0] $end
$var reg 5 F rs [4:0] $end
$var reg 5 G rt [4:0] $end
$var reg 32 H write_data [31:0] $end
$var reg 1 I write_enable_mem $end
$var reg 1 J write_enable_reg $end
$var reg 5 K write_reg [4:0] $end
$scope module mem $end
$var wire 32 L address [31:0] $end
$var wire 32 M write_data [31:0] $end
$var wire 1 I write_enable $end
$var reg 32 N read_data [31:0] $end
$var integer 32 O i [31:0] $end
$upscope $end
$scope module myADDI $end
$var wire 16 P immediate [15:0] $end
$var wire 32 Q reg_in [31:0] $end
$var wire 32 R reg_out [31:0] $end
$var wire 32 S sign_extended_value [31:0] $end
$scope module myALU $end
$var wire 32 T A [31:0] $end
$var wire 3 U ALU_Sel [2:0] $end
$var wire 32 V B [31:0] $end
$var reg 32 W ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myALU $end
$var wire 32 X A [31:0] $end
$var wire 3 Y ALU_Sel [2:0] $end
$var wire 32 Z B [31:0] $end
$var reg 32 [ ALU_Out [31:0] $end
$upscope $end
$scope module myANDI $end
$var wire 16 \ immediate [15:0] $end
$var wire 32 ] reg_in [31:0] $end
$var wire 32 ^ reg_out [31:0] $end
$var wire 32 _ sign_extended_value [31:0] $end
$scope module myALU $end
$var wire 32 ` A [31:0] $end
$var wire 3 a ALU_Sel [2:0] $end
$var wire 32 b B [31:0] $end
$var reg 32 c ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myClock $end
$var reg 1 . clk $end
$upscope $end
$scope module myORI $end
$var wire 16 d immediate [15:0] $end
$var wire 32 e reg_in [31:0] $end
$var wire 32 f reg_out [31:0] $end
$var wire 32 g sign_extended_immediate [31:0] $end
$scope module myALU $end
$var wire 32 h A [31:0] $end
$var wire 3 i ALU_Sel [2:0] $end
$var wire 32 j B [31:0] $end
$var reg 32 k ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module prog_mem $end
$var wire 32 l pc [31:0] $end
$var reg 32 m instruction [31:0] $end
$upscope $end
$scope module regFile $end
$var wire 5 n readReg1 [4:0] $end
$var wire 5 o readReg2 [4:0] $end
$var wire 32 p writeData [31:0] $end
$var wire 1 J writeEnable $end
$var wire 5 q writeReg [4:0] $end
$var reg 32 r readData1 [31:0] $end
$var reg 32 s readData2 [31:0] $end
$var integer 32 t i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 t
bx s
bx r
bx q
bx p
bx o
bx n
b100000000010000000000000000100 m
b0 l
bx k
bx j
b11 i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
b10 a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
b0 U
bx T
bx S
bx R
bx Q
bx P
b100000000 O
bx N
bx M
bx L
bx K
xJ
xI
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
b0 ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
0.
bx -
bx ,
bx +
bx *
bx )
b0 (
bx '
bx &
bx %
bx $
bx #
bx "
bx !
$end
#5000
b100000000010010000000000001111 m
b1 ?
b1 l
1.
