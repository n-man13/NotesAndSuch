$date
	Tue Oct 21 20:16:59 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module processor_tb $end
$var reg 64 ! pc [63:0] $end
$scope module myProcessor $end
$var wire 32 " ADDI_in_wire [31:0] $end
$var wire 32 # ADDI_out_wire [31:0] $end
$var wire 32 $ ALU_out_wire [31:0] $end
$var wire 32 % ANDI_in_wire [31:0] $end
$var wire 32 & ANDI_out_wire [31:0] $end
$var wire 32 ' ORI_in_wire [31:0] $end
$var wire 32 ( ORI_out_wire [31:0] $end
$var wire 64 ) initial_pc [63:0] $end
$var wire 32 * read_data_wire [31:0] $end
$var wire 32 + reg_data1_wire [31:0] $end
$var wire 32 , reg_data2_wire [31:0] $end
$var wire 1 - instruction_wire $end
$var wire 32 . instruction [31:0] $end
$var wire 16 / immediate_wire [15:0] $end
$var wire 1 0 clk $end
$var reg 32 1 ADDI_in [31:0] $end
$var reg 32 2 ADDI_out [31:0] $end
$var reg 3 3 ALU_Sel [2:0] $end
$var reg 32 4 ALU_out [31:0] $end
$var reg 32 5 ANDI_in [31:0] $end
$var reg 32 6 ANDI_out [31:0] $end
$var reg 32 7 ORI_in [31:0] $end
$var reg 32 8 ORI_out [31:0] $end
$var reg 32 9 a [31:0] $end
$var reg 32 : b [31:0] $end
$var reg 5 ; base [4:0] $end
$var reg 6 < funct [5:0] $end
$var reg 32 = mem_address [31:0] $end
$var reg 32 > mem_data [31:0] $end
$var reg 6 ? opcode [5:0] $end
$var reg 64 @ pc [63:0] $end
$var reg 5 A rd [4:0] $end
$var reg 32 B read_data [31:0] $end
$var reg 5 C read_reg1 [4:0] $end
$var reg 5 D read_reg2 [4:0] $end
$var reg 32 E reg_data1 [31:0] $end
$var reg 32 F reg_data2 [31:0] $end
$var reg 5 G rs [4:0] $end
$var reg 5 H rt [4:0] $end
$var reg 32 I write_data [31:0] $end
$var reg 1 J write_enable_mem $end
$var reg 1 K write_enable_reg $end
$var reg 5 L write_reg [4:0] $end
$scope module mem $end
$var wire 32 M address [31:0] $end
$var wire 32 N write_data [31:0] $end
$var wire 1 J write_enable $end
$var reg 32 O read_data [31:0] $end
$var integer 32 P i [31:0] $end
$upscope $end
$scope module myADDI $end
$var wire 16 Q immediate [15:0] $end
$var wire 32 R reg_in [31:0] $end
$var wire 32 S reg_out [31:0] $end
$var wire 32 T sign_extended_value [31:0] $end
$scope module myALU $end
$var wire 32 U A [31:0] $end
$var wire 3 V ALU_Sel [2:0] $end
$var wire 32 W B [31:0] $end
$var reg 32 X ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myALU $end
$var wire 32 Y A [31:0] $end
$var wire 3 Z ALU_Sel [2:0] $end
$var wire 32 [ B [31:0] $end
$var reg 32 \ ALU_Out [31:0] $end
$upscope $end
$scope module myANDI $end
$var wire 16 ] immediate [15:0] $end
$var wire 32 ^ reg_in [31:0] $end
$var wire 32 _ reg_out [31:0] $end
$var wire 32 ` sign_extended_value [31:0] $end
$scope module myALU $end
$var wire 32 a A [31:0] $end
$var wire 3 b ALU_Sel [2:0] $end
$var wire 32 c B [31:0] $end
$var reg 32 d ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myClock $end
$var reg 1 0 clk $end
$upscope $end
$scope module myORI $end
$var wire 16 e immediate [15:0] $end
$var wire 32 f reg_in [31:0] $end
$var wire 32 g reg_out [31:0] $end
$var wire 32 h sign_extended_immediate [31:0] $end
$scope module myALU $end
$var wire 32 i A [31:0] $end
$var wire 3 j ALU_Sel [2:0] $end
$var wire 32 k B [31:0] $end
$var reg 32 l ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module prog_mem $end
$var wire 64 m pc [63:0] $end
$var wire 32 n instruction [31:0] $end
$var reg 32 o instruction_reg [31:0] $end
$upscope $end
$scope module regFile $end
$var wire 5 p readReg1 [4:0] $end
$var wire 5 q readReg2 [4:0] $end
$var wire 32 r writeData [31:0] $end
$var wire 1 K writeEnable $end
$var wire 5 s writeReg [4:0] $end
$var reg 32 t readData1 [31:0] $end
$var reg 32 u readData2 [31:0] $end
$var integer 32 v i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 v
b0 u
b0 t
b0 s
bx r
b0 q
b0 p
bx o
bx n
bx m
bx l
bx k
b11 j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
b10 b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
b110 Z
bx Y
bx X
bx W
b0 V
bx U
bx T
bx S
bx R
bx Q
b100000000 P
bx O
bx N
bx M
b0 L
0K
xJ
bx I
b0 H
b0 G
bx F
bx E
b0 D
b0 C
bx B
b0 A
bx @
bx ?
bx >
bx =
b0 <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
b110 3
bx 2
bx 1
10
bx /
bx .
x-
bx ,
bx +
bx *
b0 )
bx (
bx '
bx &
bx %
bx $
bx #
bx "
b0 !
$end
#5000
00
#10000
10
#15000
00
#20000
10
#25000
00
#30000
10
#35000
00
#40000
10
#45000
00
#50000
10
#55000
00
#60000
10
#65000
00
#70000
10
#75000
00
#80000
10
#85000
00
#90000
10
#95000
00
#100000
10
#105000
00
#110000
10
#115000
00
#120000
10
#125000
00
#130000
10
#135000
00
#140000
10
#145000
00
#150000
10
#155000
00
#160000
10
#165000
00
#170000
10
#175000
00
#180000
10
#185000
00
#190000
10
#195000
00
#200000
10
b1000 !
b1000 )
#205000
00
#210000
10
#215000
00
#220000
10
#225000
00
#230000
10
#235000
00
#240000
10
#245000
00
#250000
10
#255000
00
#260000
10
#265000
00
#270000
10
#275000
00
#280000
10
#285000
00
#290000
10
#295000
00
#300000
10
#305000
00
#310000
10
#315000
00
#320000
10
#325000
00
#330000
10
#335000
00
#340000
10
#345000
00
#350000
10
#355000
00
#360000
10
#365000
00
#370000
10
#375000
00
#380000
10
#385000
00
#390000
10
#395000
00
#400000
10
b10100 !
b10100 )
#405000
00
#410000
10
#415000
00
#420000
10
#425000
00
#430000
10
#435000
00
#440000
10
#445000
00
#450000
10
#455000
00
#460000
10
#465000
00
#470000
10
#475000
00
#480000
10
#485000
00
#490000
10
#495000
00
#500000
10
#505000
00
#510000
10
#515000
00
#520000
10
#525000
00
#530000
10
#535000
00
#540000
10
#545000
00
#550000
10
#555000
00
#560000
10
#565000
00
#570000
10
#575000
00
#580000
10
#585000
00
#590000
10
#595000
00
#600000
10
