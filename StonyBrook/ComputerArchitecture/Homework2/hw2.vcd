$date
	Tue Oct 21 22:24:12 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module processor_tb $end
$scope module myProcessor $end
$var wire 32 ! ADDI_in_wire [31:0] $end
$var wire 32 " ANDI_in_wire [31:0] $end
$var wire 32 # ORI_in_wire [31:0] $end
$var wire 32 $ initial_pc [31:0] $end
$var wire 32 % read_data_wire [31:0] $end
$var wire 1 & write_enable $end
$var wire 32 ' reg_data2 [31:0] $end
$var wire 32 ( reg_data1 [31:0] $end
$var wire 1 ) instruction_wire $end
$var wire 32 * instruction [31:0] $end
$var wire 16 + immediate_wire [15:0] $end
$var wire 1 , clk $end
$var wire 32 - ORI_out_wire [31:0] $end
$var wire 32 . ANDI_out_wire [31:0] $end
$var wire 32 / ALU_out_wire [31:0] $end
$var wire 32 0 ADDI_out_wire [31:0] $end
$var reg 32 1 ADDI_in [31:0] $end
$var reg 3 2 ALU_Sel [2:0] $end
$var reg 32 3 ANDI_in [31:0] $end
$var reg 32 4 ORI_in [31:0] $end
$var reg 32 5 a [31:0] $end
$var reg 32 6 b [31:0] $end
$var reg 5 7 base [4:0] $end
$var reg 6 8 funct [5:0] $end
$var reg 32 9 mem_address [31:0] $end
$var reg 32 : mem_data [31:0] $end
$var reg 6 ; opcode [5:0] $end
$var reg 32 < pc [31:0] $end
$var reg 5 = rd [4:0] $end
$var reg 32 > read_data [31:0] $end
$var reg 5 ? read_reg1 [4:0] $end
$var reg 5 @ read_reg2 [4:0] $end
$var reg 5 A rs [4:0] $end
$var reg 5 B rt [4:0] $end
$var reg 32 C write_data [31:0] $end
$var reg 1 D write_enable_mem $end
$var reg 1 E write_enable_reg $end
$var reg 5 F write_reg [4:0] $end
$scope module mem $end
$var wire 32 G address [31:0] $end
$var wire 32 H write_data [31:0] $end
$var wire 1 D write_enable $end
$var reg 32 I read_data [31:0] $end
$var integer 32 J i [31:0] $end
$upscope $end
$scope module myADDI $end
$var wire 16 K immediate [15:0] $end
$var wire 32 L reg_in [31:0] $end
$var wire 32 M sign_extended_value [31:0] $end
$var wire 32 N reg_out [31:0] $end
$scope module myADDI_ALU $end
$var wire 32 O A [31:0] $end
$var wire 3 P ALU_Sel [2:0] $end
$var wire 32 Q B [31:0] $end
$var reg 32 R ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myALU $end
$var wire 32 S A [31:0] $end
$var wire 3 T ALU_Sel [2:0] $end
$var wire 32 U B [31:0] $end
$var reg 32 V ALU_Out [31:0] $end
$upscope $end
$scope module myANDI $end
$var wire 16 W immediate [15:0] $end
$var wire 32 X reg_in [31:0] $end
$var wire 32 Y sign_extended_value [31:0] $end
$var wire 32 Z reg_out [31:0] $end
$scope module myALU $end
$var wire 32 [ A [31:0] $end
$var wire 3 \ ALU_Sel [2:0] $end
$var wire 32 ] B [31:0] $end
$var reg 32 ^ ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myClock $end
$var reg 1 , clk $end
$upscope $end
$scope module myORI $end
$var wire 16 _ immediate [15:0] $end
$var wire 32 ` reg_in [31:0] $end
$var wire 32 a sign_extended_immediate [31:0] $end
$var wire 32 b reg_out [31:0] $end
$scope module myALU $end
$var wire 32 c A [31:0] $end
$var wire 3 d ALU_Sel [2:0] $end
$var wire 32 e B [31:0] $end
$var reg 32 f ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module prog_mem $end
$var wire 32 g pc [31:0] $end
$var wire 32 h instruction [31:0] $end
$var reg 32 i instruction_reg [31:0] $end
$upscope $end
$scope module regFile $end
$var wire 5 j readReg1 [4:0] $end
$var wire 5 k readReg2 [4:0] $end
$var wire 32 l writeData [31:0] $end
$var wire 1 E writeEnable $end
$var wire 5 m writeReg [4:0] $end
$var reg 32 n readData1 [31:0] $end
$var reg 32 o readData2 [31:0] $end
$var integer 32 p i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 p
b0 o
b0 n
b1000 m
bx l
b0 k
b0 j
b100000000010000000000000000100 i
b100000000010000000000000000100 h
b0 g
b100 f
b100 e
b11 d
b0 c
b100 b
b100 a
b0 `
b100 _
b0 ^
b100 ]
b10 \
b0 [
b0 Z
b100 Y
b0 X
b100 W
bx V
bx U
b110 T
bx S
bx R
b100 Q
b0 P
bx O
bx N
b100 M
bx L
b100 K
b100000000 J
bx I
bx H
bx G
b1000 F
1E
0D
bx C
b1000 B
b0 A
b0 @
b0 ?
bx >
b0 =
b0 <
b1000 ;
bx :
bx 9
b0 8
bx 7
bx 6
bx 5
b0 4
b0 3
b110 2
bx 1
bx 0
bx /
b0 .
b100 -
1,
b100 +
b100000000010000000000000000100 *
0)
b0 (
b0 '
1&
bx %
b0 $
b0 #
b0 "
bx !
$end
#1000
0&
0E
#5000
0,
#10000
b1111 -
b1111 b
b1111 f
1)
b1111 M
b1111 Q
b1111 Y
b1111 ]
b1111 a
b1111 e
b1111 +
b1111 K
b1111 W
b1111 _
b1111 0
b1111 N
b1111 R
b100000000010010000000000001111 *
b100000000010010000000000001111 h
b100000000010010000000000001111 i
1&
1E
b0 !
b0 L
b0 O
b0 1
b1 <
b1 g
1,
#11000
0&
0E
#15000
0,
#20000
b10100 0
b10100 N
b10100 R
b10100 -
b10100 b
b10100 f
0)
b10100 M
b10100 Q
b10100 Y
b10100 ]
b10100 a
b10100 e
b10100 +
b10100 K
b10100 W
b10100 _
b100000000010100000000000010100 *
b100000000010100000000000010100 h
b100000000010100000000000010100 i
b1111 C
b1111 l
1&
1E
b1001 F
b1001 m
b1001 B
b10 <
b10 g
1,
#21000
0&
0E
#25000
0,
#30000
b1000 0
b1000 N
b1000 R
b1000 -
b1000 b
b1000 f
b1000 M
b1000 Q
b1000 Y
b1000 ]
b1000 a
b1000 e
b1000 +
b1000 K
b1000 W
b1000 _
b100000000100010000000000001000 *
b100000000100010000000000001000 h
b100000000100010000000000001000 i
b10100 C
b10100 l
1&
1E
b1010 F
b1010 m
b1010 B
b11 <
b11 g
1,
#31000
0&
0E
#35000
0,
#40000
b0 0
b0 N
b0 R
b0 -
b0 b
b0 f
b0 M
b0 Q
b0 Y
b0 ]
b0 a
b0 e
b0 +
b0 K
b0 W
b0 _
b10101110001010000000000000000000 *
b10101110001010000000000000000000 h
b10101110001010000000000000000000 i
b1000 C
b1000 l
1&
1E
b10001 F
b10001 m
b10001 B
b100 <
b100 g
1,
#41000
0&
0E
#45000
0,
#50000
b0 I
b1000 0
b1000 N
b1000 R
b1000 -
b1000 b
b1000 f
b1000 M
b1000 Q
b1000 Y
b1000 ]
b1000 a
b1000 e
b1000 +
b1000 K
b1000 W
b1000 _
bx '
bx o
bx (
bx n
b10101110001010010000000000001000 *
b10101110001010010000000000001000 h
b10101110001010010000000000001000 i
b0 :
b0 H
1D
b0 9
b0 G
b1000 @
b1000 k
bx ?
bx j
b1000 B
b10001 A
b101011 ;
b101 <
b101 g
1,
#51000
0D
#55000
0,
#60000
b11111111111111111111111111111100 -
b11111111111111111111111111111100 b
b11111111111111111111111111111100 f
b11111111111111111111111111111100 M
b11111111111111111111111111111100 Q
b11111111111111111111111111111100 Y
b11111111111111111111111111111100 ]
b11111111111111111111111111111100 a
b11111111111111111111111111111100 e
b1111111111111100 +
b1111111111111100 K
b1111111111111100 W
b1111111111111100 _
bx 0
bx N
bx R
b1111 '
b1111 o
b10101110001010101111111111111100 *
b10101110001010101111111111111100 h
b10101110001010101111111111111100 i
bx :
bx H
1D
b1000 9
b1000 G
bx !
bx L
bx O
bx 1
b1001 @
b1001 k
b1001 B
b110 <
b110 g
1,
#61000
bx I
0D
#65000
0,
#70000
b0 -
b0 b
b0 f
b0 M
b0 Q
b0 Y
b0 ]
b0 a
b0 e
b0 +
b0 K
b0 W
b0 _
b10100 '
b10100 o
b11111100000000000000000000000000 *
b11111100000000000000000000000000 h
b11111100000000000000000000000000 i
b1111 :
b1111 H
1D
bx 9
bx G
b1010 @
b1010 k
b1010 B
b111 <
b111 g
1,
#71000
0D
#75000
0,
#80000
b1000 -
b1000 b
b1000 f
b1000 M
b1000 Q
b1000 Y
b1000 ]
b1000 a
b1000 e
b1000 +
b1000 K
b1000 W
b1000 _
b100000000010000000000000001000 *
b100000000010000000000000001000 h
b100000000010000000000000001000 i
b111111 ;
b1000 <
b1000 g
1,
