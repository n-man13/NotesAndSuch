$date
	Tue Oct 21 16:45:42 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module processor_tb $end
$scope module myProcessor $end
$var wire 32 ! ADDI_in_wire [31:0] $end
$var wire 32 " ADDI_out_wire [31:0] $end
$var wire 32 # ALU_out_wire [31:0] $end
$var wire 32 $ ANDI_in_wire [31:0] $end
$var wire 32 % ANDI_out_wire [31:0] $end
$var wire 32 & ORI_in_wire [31:0] $end
$var wire 32 ' ORI_out_wire [31:0] $end
$var wire 32 ( initial_pc [31:0] $end
$var wire 32 ) instruction_wire [31:0] $end
$var wire 32 * read_data_wire [31:0] $end
$var wire 32 + reg_data1_wire [31:0] $end
$var wire 32 , reg_data2_wire [31:0] $end
$var wire 16 - immediate_wire [15:0] $end
$var wire 1 . clk $end
$var reg 32 / ADDI_in [31:0] $end
$var reg 32 0 ADDI_out [31:0] $end
$var reg 3 1 ALU_Sel [2:0] $end
$var reg 32 2 ALU_out [31:0] $end
$var reg 32 3 ANDI_in [31:0] $end
$var reg 32 4 ANDI_out [31:0] $end
$var reg 32 5 ORI_in [31:0] $end
$var reg 32 6 ORI_out [31:0] $end
$var reg 32 7 a [31:0] $end
$var reg 32 8 b [31:0] $end
$var reg 5 9 base [4:0] $end
$var reg 6 : funct [5:0] $end
$var reg 32 ; instruction [31:0] $end
$var reg 32 < mem_address [31:0] $end
$var reg 32 = mem_data [31:0] $end
$var reg 6 > opcode [5:0] $end
$var reg 32 ? pc [31:0] $end
$var reg 5 @ rd [4:0] $end
$var reg 32 A read_data [31:0] $end
$var reg 5 B read_reg1 [4:0] $end
$var reg 5 C read_reg2 [4:0] $end
$var reg 32 D reg_data1 [31:0] $end
$var reg 32 E reg_data2 [31:0] $end
$var reg 5 F rs [4:0] $end
$var reg 5 G rt [4:0] $end
$var reg 32 H write_data [31:0] $end
$var reg 1 I write_enable_mem $end
$var reg 1 J write_enable_reg $end
$var reg 5 K write_reg [4:0] $end
$scope module mem $end
$var wire 32 L address [31:0] $end
$var wire 32 M write_data [31:0] $end
$var wire 1 I write_enable $end
$var reg 32 N read_data [31:0] $end
$var integer 32 O i [31:0] $end
$upscope $end
$scope module myADDI $end
$var wire 16 P immediate [15:0] $end
$var wire 32 Q reg_in [31:0] $end
$var wire 32 R reg_out [31:0] $end
$var wire 32 S sign_extended_value [31:0] $end
$scope module myALU $end
$var wire 32 T A [31:0] $end
$var wire 3 U ALU_Sel [2:0] $end
$var wire 32 V B [31:0] $end
$var reg 32 W ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myALU $end
$var wire 32 X A [31:0] $end
$var wire 3 Y ALU_Sel [2:0] $end
$var wire 32 Z B [31:0] $end
$var reg 32 [ ALU_Out [31:0] $end
$upscope $end
$scope module myANDI $end
$var wire 16 \ immediate [15:0] $end
$var wire 32 ] reg_in [31:0] $end
$var wire 32 ^ reg_out [31:0] $end
$var wire 32 _ sign_extended_value [31:0] $end
$scope module myALU $end
$var wire 32 ` A [31:0] $end
$var wire 3 a ALU_Sel [2:0] $end
$var wire 32 b B [31:0] $end
$var reg 32 c ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myClock $end
$var reg 1 . clk $end
$upscope $end
$scope module myORI $end
$var wire 16 d immediate [15:0] $end
$var wire 32 e reg_in [31:0] $end
$var wire 32 f reg_out [31:0] $end
$var wire 32 g sign_extended_immediate [31:0] $end
$scope module myALU $end
$var wire 32 h A [31:0] $end
$var wire 3 i ALU_Sel [2:0] $end
$var wire 32 j B [31:0] $end
$var reg 32 k ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module prog_mem $end
$var wire 32 l instruction [31:0] $end
$var wire 32 m pc [31:0] $end
$var reg 32 n instruction_reg [31:0] $end
$upscope $end
$scope module regFile $end
$var wire 5 o readReg1 [4:0] $end
$var wire 5 p readReg2 [4:0] $end
$var wire 32 q writeData [31:0] $end
$var wire 1 J writeEnable $end
$var wire 5 r writeReg [4:0] $end
$var reg 32 s readData1 [31:0] $end
$var reg 32 t readData2 [31:0] $end
$var integer 32 u i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 u
bx t
bx s
bx r
bx q
bx p
bx o
b100000000010000000000000000100 n
b0 m
bx l
bx k
bx j
b11 i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
b10 a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
b0 U
bx T
bx S
bx R
bx Q
bx P
b100000000 O
bx N
bx M
bx L
bx K
xJ
xI
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
b0 ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
0.
bx -
bx ,
bx +
bx *
bx )
b0 (
bx '
bx &
bx %
bx $
bx #
bx "
bx !
$end
#5000
b100000000010010000000000001111 n
b1 ?
b1 m
1.
#10000
0.
#15000
b100000000010100000000000010100 n
b10 ?
b10 m
1.
#20000
0.
#25000
b100000000100010000000000001000 n
b11 ?
b11 m
1.
#30000
0.
#35000
b10101110001010000000000000000000 n
b100 ?
b100 m
1.
#40000
0.
#45000
b10101110001010010000000000001000 n
b101 ?
b101 m
1.
#50000
0.
#55000
b10101110001010101111111111111100 n
b110 ?
b110 m
1.
#60000
0.
#65000
b11111100000000000000000000000000 n
b111 ?
b111 m
1.
#70000
0.
#75000
b100000000010000000000000001000 n
b1000 ?
b1000 m
1.
#80000
0.
#85000
b100000000010010000000000001111 n
b1001 ?
b1001 m
1.
#90000
0.
#95000
b10101101000010010000000000000000 n
b1010 ?
b1010 m
1.
#100000
0.
#105000
b1001010000101000000100000 n
b1011 ?
b1011 m
1.
#110000
0.
#115000
b1001010000101100000100010 n
b1100 ?
b1100 m
1.
#120000
0.
#125000
b1010010111000100000000010 n
b1101 ?
b1101 m
1.
#130000
0.
#135000
b100000000010000000000000000100 n
b1110 ?
b1110 m
1.
#140000
0.
#145000
b10001101000100101111111111111100 n
b1111 ?
b1111 m
1.
#150000
0.
#155000
b10001100101001000000100010 n
b10000 ?
b10000 m
1.
#160000
0.
#165000
b10001000001001000000000000 n
b10001 ?
b10001 m
1.
#170000
0.
#175000
b10101101000100100000000000000000 n
b10010 ?
b10010 m
1.
#180000
0.
#185000
b11111100000000000000000000000000 n
b10011 ?
b10011 m
1.
#190000
0.
#195000
bx n
b10100 ?
b10100 m
1.
#200000
0.
