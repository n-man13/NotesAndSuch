$date
	Tue Oct 21 21:58:35 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module processor_tb $end
$var reg 64 ! pc [63:0] $end
$scope module myProcessor $end
$var wire 32 ! ADDI_in_wire [31:0] $end
$var wire 32 " ANDI_in_wire [31:0] $end
$var wire 32 # ORI_in_wire [31:0] $end
$var wire 32 $ initial_pc [31:0] $end
$var wire 32 % read_data_wire [31:0] $end
$var wire 1 & write_enable $end
$var wire 32 ' reg_data2 [31:0] $end
$var wire 32 ( reg_data1 [31:0] $end
$var wire 1 ) instruction_wire $end
$var wire 32 * instruction [31:0] $end
$var wire 16 + immediate_wire [15:0] $end
$var wire 1 , clk $end
$var wire 32 - ORI_out_wire [31:0] $end
$var wire 32 . ANDI_out_wire [31:0] $end
$var wire 32 / ALU_out_wire [31:0] $end
$var wire 32 0 ADDI_out_wire [31:0] $end
$var reg 32 1 ADDI_in [31:0] $end
$var reg 3 2 ALU_Sel [2:0] $end
$var reg 32 3 ALU_out [31:0] $end
$var reg 32 4 ANDI_in [31:0] $end
$var reg 32 5 ORI_in [31:0] $end
$var reg 32 6 a [31:0] $end
$var reg 32 7 b [31:0] $end
$var reg 5 8 base [4:0] $end
$var reg 6 9 funct [5:0] $end
$var reg 32 : mem_address [31:0] $end
$var reg 32 ; mem_data [31:0] $end
$var reg 6 < opcode [5:0] $end
$var reg 32 = pc [31:0] $end
$var reg 5 > rd [4:0] $end
$var reg 32 ? read_data [31:0] $end
$var reg 5 @ read_reg1 [4:0] $end
$var reg 5 A read_reg2 [4:0] $end
$var reg 5 B rs [4:0] $end
$var reg 5 C rt [4:0] $end
$var reg 32 D write_data [31:0] $end
$var reg 1 E write_enable_mem $end
$var reg 1 F write_enable_reg $end
$var reg 5 G write_reg [4:0] $end
$scope module mem $end
$var wire 32 H address [31:0] $end
$var wire 32 I write_data [31:0] $end
$var wire 1 E write_enable $end
$var reg 32 J read_data [31:0] $end
$var integer 32 K i [31:0] $end
$upscope $end
$scope module myADDI $end
$var wire 16 L immediate [15:0] $end
$var wire 32 M reg_in [31:0] $end
$var wire 32 N sign_extended_value [31:0] $end
$var wire 32 O reg_out [31:0] $end
$scope module myADDI_ALU $end
$var wire 32 P A [31:0] $end
$var wire 3 Q ALU_Sel [2:0] $end
$var wire 32 R B [31:0] $end
$var reg 32 S ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myALU $end
$var wire 32 U A [31:0] $end
$var wire 3 V ALU_Sel [2:0] $end
$var wire 32 W B [31:0] $end
$var reg 32 X ALU_Out [31:0] $end
$upscope $end
$scope module myANDI $end
$var wire 16 X immediate [15:0] $end
$var wire 32 Y reg_in [31:0] $end
$var wire 32 Z sign_extended_value [31:0] $end
$var wire 32 [ reg_out [31:0] $end
$scope module myALU $end
$var wire 32 \ A [31:0] $end
$var wire 3 ] ALU_Sel [2:0] $end
$var wire 32 ^ B [31:0] $end
$var reg 32 _ ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module myClock $end
$var reg 1 , clk $end
$upscope $end
$scope module myORI $end
$var wire 16 ` immediate [15:0] $end
$var wire 32 a reg_in [31:0] $end
$var wire 32 b sign_extended_immediate [31:0] $end
$var wire 32 c reg_out [31:0] $end
$scope module myALU $end
$var wire 32 d A [31:0] $end
$var wire 3 e ALU_Sel [2:0] $end
$var wire 32 f B [31:0] $end
$var reg 32 g ALU_Out [31:0] $end
$upscope $end
$upscope $end
$scope module prog_mem $end
$var wire 32 h pc [31:0] $end
$var wire 32 i instruction [31:0] $end
$var reg 32 j instruction_reg [31:0] $end
$upscope $end
$scope module regFile $end
$var wire 5 k readReg1 [4:0] $end
$var wire 5 l readReg2 [4:0] $end
$var wire 32 m writeData [31:0] $end
$var wire 1 F writeEnable $end
$var wire 5 n writeReg [4:0] $end
$var reg 32 o readData1 [31:0] $end
$var reg 32 p readData2 [31:0] $end
$var integer 32 q i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 q
b0 p
b0 o
b1000 n
bx m
b0 l
b0 k
b100000000010000000000000000100 j
b100000000010000000000000000100 i
b0 h
bx1xx g
b100 f
b11 e
bx d
bx1xx c
b100 b
bx a
b100 `
b0x00 _
b100 ^
b10 ]
bx \
b0x00 [
b100 Z
bx Y
b100 X
bx W
bx V
b110 U
bx T
bx S
b100 R
b0 Q
bx P
bx O
b100 N
bx M
b100 L
b100000000 K
bx J
bx I
bx H
b1000 G
1F
xE
bx D
b1000 C
b0 B
b0 A
b0 @
bx ?
b0 >
b0 =
b1000 <
bx ;
bx :
b0 9
bx 8
bx 7
bx 6
bx 5
bx 4
b110 3
bx 2
bx 1
bx 0
bx /
b0x00 .
bx1xx -
1,
b100 +
b100000000010000000000000000100 *
0)
b0 (
b0 '
1&
bx %
b0 $
bx #
bx "
b0 !
$end
#1000
0&
0F
#5000
0,
#10000
b0xxxx .
b0xxxx [
b0xxxx _
bx1111 -
bx1111 c
bx1111 g
1)
b1111 N
b1111 R
b1111 Z
b1111 ^
b1111 b
b1111 f
b1111 +
b1111 L
b1111 X
b1111 `
b1111 0
b1111 O
b1111 S
b100000000010010000000000001111 *
b100000000010010000000000001111 i
b100000000010010000000000001111 j
1&
1F
b0 !
b0 M
b0 P
b0 1
b1 =
b1 h
1,
#11000
0&
0F
#15000
0,
#20000
b10100 0
b10100 O
b10100 S
b0x0x00 .
b0x0x00 [
b0x0x00 _
bx1x1xx -
bx1x1xx c
bx1x1xx g
0)
b10100 N
b10100 R
b10100 Z
b10100 ^
b10100 b
b10100 f
b10100 +
b10100 L
b10100 X
b10100 `
b100000000010100000000000010100 *
b100000000010100000000000010100 i
b100000000010100000000000010100 j
b1111 D
b1111 m
1&
1F
b1001 G
b1001 n
b1001 C
b10 =
b10 h
1,
#21000
0&
0F
#25000
0,
#30000
b1000 0
b1000 O
b1000 S
b0x000 .
b0x000 [
b0x000 _
bx1xxx -
bx1xxx c
bx1xxx g
b1000 N
b1000 R
b1000 Z
b1000 ^
b1000 b
b1000 f
b1000 +
b1000 L
b1000 X
b1000 `
b100000000100010000000000001000 *
b100000000100010000000000001000 i
b100000000100010000000000001000 j
b10100 D
b10100 m
1&
1F
b1010 G
b1010 n
b1010 C
b11 =
b11 h
1,
#31000
0&
0F
#35000
0,
#40000
b0 0
b0 O
b0 S
b0 .
b0 [
b0 _
bx -
bx c
bx g
b0 N
b0 R
b0 Z
b0 ^
b0 b
b0 f
b0 +
b0 L
b0 X
b0 `
b10101110001010000000000000000000 *
b10101110001010000000000000000000 i
b10101110001010000000000000000000 j
b1000 D
b1000 m
1&
1F
b10001 G
b10001 n
b10001 C
b100 =
b100 h
1,
#41000
0&
0F
#45000
0,
#50000
b0 J
b1000 0
b1000 O
b1000 S
b0x000 .
b0x000 [
b0x000 _
bx1xxx -
bx1xxx c
bx1xxx g
b1000 N
b1000 R
b1000 Z
b1000 ^
b1000 b
b1000 f
b1000 +
b1000 L
b1000 X
b1000 `
bx '
bx p
bx (
bx o
b10101110001010010000000000001000 *
b10101110001010010000000000001000 i
b10101110001010010000000000001000 j
b0 ;
b0 I
1E
b0 :
b0 H
b1000 A
b1000 l
bx @
bx k
b1000 C
b10001 B
b101011 <
b101 =
b101 h
1,
#51000
0E
#55000
0,
#60000
bx00 .
bx00 [
bx00 _
b111111111111111111111111111111xx -
b111111111111111111111111111111xx c
b111111111111111111111111111111xx g
b11111111111111111111111111111100 N
b11111111111111111111111111111100 R
b11111111111111111111111111111100 Z
b11111111111111111111111111111100 ^
b11111111111111111111111111111100 b
b11111111111111111111111111111100 f
b1111111111111100 +
b1111111111111100 L
b1111111111111100 X
b1111111111111100 `
bx 0
bx O
bx S
b1111 '
b1111 p
b10101110001010101111111111111100 *
b10101110001010101111111111111100 i
b10101110001010101111111111111100 j
bx ;
bx I
1E
b1000 :
b1000 H
bx !
bx M
bx P
bx 1
b1001 A
b1001 l
b1001 C
b110 =
b110 h
1,
#61000
bx J
0E
#65000
0,
#70000
b0 .
b0 [
b0 _
bx -
bx c
bx g
b0 N
b0 R
b0 Z
b0 ^
b0 b
b0 f
b0 +
b0 L
b0 X
b0 `
b10100 '
b10100 p
b11111100000000000000000000000000 *
b11111100000000000000000000000000 i
b11111100000000000000000000000000 j
b1111 ;
b1111 I
1E
bx :
bx H
b1010 A
b1010 l
b1010 C
b111 =
b111 h
1,
#71000
0E
#75000
0,
#80000
b0x000 .
b0x000 [
b0x000 _
bx1xxx -
bx1xxx c
bx1xxx g
b1000 N
b1000 R
b1000 Z
b1000 ^
b1000 b
b1000 f
b1000 +
b1000 L
b1000 X
b1000 `
b100000000010000000000000001000 *
b100000000010000000000000001000 i
b100000000010000000000000001000 j
b111111 <
b1000 =
b1000 h
1,
#82000
